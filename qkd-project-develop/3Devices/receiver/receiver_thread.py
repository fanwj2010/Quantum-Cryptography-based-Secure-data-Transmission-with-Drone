import json, structimport sysimport threadingfrom socket import *from PySide2.QtWidgets import QLineEdit, QPlainTextEdit, QMessageBoximport _threadimport qkdimport timeimport osimport PySide2from PySide2 import QtWidgetsfrom PySide2.QtUiTools import QUiLoaderfrom PySide2.QtCore import Signal, QObjectimport qkdimport protocolmain_win = Nonedirname = os.path.dirname(PySide2.__file__)plugin_path = os.path.join(dirname, 'plugins', 'platforms')os.environ['QT_QPA_PLATFORM_PLUGIN_PATH'] = plugin_pathnum_of_qubits = 100listofBasis = list()listofBits = list()listofQubits = list()listofRcvbasis = list()finalKey = list()qubitsStr = ""class Signals(QObject):    Line_print = Signal(QLineEdit, str)    plainText_print = Signal(QPlainTextEdit, str)# global_ms = Signals()# default valueport = 20002receiveer_ip = ''# '192.168.0.173'receiver_port = -1#  20002receiver = socket(AF_INET, SOCK_STREAM)class LoginWin:    # initialization:    def __init__(self):        super().__init__()        self.ui = QUiLoader().load('ui/receiver.ui')        # self.ui.hostLineEdit.setText("127.0.0.1")        # self.ui.portLlineEdit.setText("20004")        self.ui.lenLineEdit.setPlaceholderText("Unknown")        # self.ui.GeneratePushButton.clicked.connect(self.generate_qubits)        self.ui.connectPushButton.clicked.connect(self.connectFunc)        self.ms = Signals()        # self.ui.keyPlainTextEdit.setPlainText(qkd.listtoString(qkd.listofBitstoSymbol(finalKey)))        # 自定义信号的处理函数        self.ms.plainText_print.connect(self.printToGui)        self.ms.Line_print.connect(self.printToGui)    def printToGui(self, tb, text):        tb.append(str(text))        tb.ensureCursorVisible()    def connectFunc(self):        global port, receiver, receiveer_ip, receiver_port        # receiver = socket(AF_INET,SOCK_STREAM)        port = int(self.ui.Recv_PortEdit.displayText())        address = ('', port)        receiver.bind(address)        receiver.listen(5)        while True:            try:                sock, addr = receiver.accept()                threading.Thread(target=self.tcplink, args=(sock, addr)).start()                break            except Exception:                message_error = QMessageBox(QMessageBox.Warning, 'Warning', 'input error!')                message_error.exec_()                return    def tcplink(self, sock, addr):        print('connection from %s' % addr)        while True:            recv_data = sock.recv(2048)            if not recv_data or recv_data.decode('utf-8') == 'exit':                break            self.get_Recvlen_and_generateBases(sock)            self.Recv_bases(recv_data)            # self.            operaCode = protocol.parse_request_operaCode(recv_data)            # 0: drone fly ; 1: take photo            if operaCode == 0 or 1 or 3:                return            # 4: send receiver's ip and port            if operaCode == 4:                _, receiveer_ip, receiver_port = protocol.parse_recvip_info(recv_data)                return            # 2: receive qubits from pi            if operaCode == 2:                self.Recv_qubits(sock)                pass        receiver.close()        # print(addr,"connect")    def get_Recvlen_and_generateBases(self,sock):        def threadFunc():            global listofBasis, listofQubits            self.ms.Line_print.emit(self.ui.lenLineEdit, str(num_of_qubits))            listofBasis = qkd.generateRandomBasis(num_of_qubits)            symbolofBasis = qkd.listofBasistoSymbol(listofBasis)            listofBasis = qkd.listtoString(symbolofBasis)            sock.sendall(listofBasis.encode())            self.ms.plainText_print.emit(self.ui.basePlainTextEdit, qkd.listtoString(symbolofBasis))            # print(len(qubitStr))        pass        RecvLen_thread = threading.Thread(target=threadFunc)        RecvLen_thread.start()        pass    def Recv_bases(self, recv_data):        def threadFunc():            global listofBasis            recvBasisStr = recv_data.decode()            listofRecvBasis = list()            for i in recvBasisStr:                if i == "0":                    listofRecvBasis.append(0)                else:                    listofRecvBasis.append(1)            listofRecvBasis_sysmbol = qkd.listofBasistoSymbol(listofRecvBasis)            listofRecvBasis_sysmbol_string = qkd.listtoString(listofRecvBasis_sysmbol)            self.ms.plainText_print.emit(self.ui.recvBasePlainTextEdit, listofRecvBasis_sysmbol_string)            pass        Recv_bases_thread = threading.Thread(target=threadFunc)        Recv_bases_thread.start()        pass    def Recv_qubits(self, sock):        def threadFunc():            global num_of_qubits, listofQubits, qubitsStr            qubitStr = receiver.recv(4028).decode()            for i in range(int(len(qubitStr) / 2)):                listofQubits.append(qkd.Qubit(qubitStr[2 * i], qubitStr[2 * i + 1]))            self.ms.plainText_print.emit(self.ui.bitsPlainTextEdit, qkd.listtoString(listofQubits))            pass        Recv_qubitsThread = threading.Thread(target=threadFunc())        Recv_qubitsThread.start()        pass    def get_Finalkey_cal_QBER(self, listofBasis):        def threadFunc():            global listofRcvbasis            basisCompare, qber = qkd.compareBasis(listofBasis, listofRcvbasis)            final_Key = qkd.showFinalkeys(listofBits, basisCompare)            self.ms.plainText_print.emit(self.ui.keyPlainTextEdit, qkd.listtoString(final_Key))            self.ms.Line_print.emit(self.ui.QBEREdit, str(qber * 100))            pass        finalKeyThread = threading.Thread(target=threadFunc())        finalKeyThread.start()        passif __name__ == '__main__':    app = QtWidgets.QApplication(sys.argv)    wm = LoginWin()    wm.ui.show()    sys.exit(app.exec_())